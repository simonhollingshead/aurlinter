#!/bin/bash

source config

prep() {
	if [[ ! -d ./res/sourced ]]; then
		bsdtar -C ./res -xzf ./res/sourceall.tar.gz
	fi
}

coalesce() {
	if [[ -f res/goodurls ]]; then
		comm -23 <(sort res/urllist) <(sort res/goodurls) | sponge res/urllist
		rm res/goodurls
	fi
}

urlcheck() {
	SHELL=/usr/bin/bash parallel -N 50 -j50 '
	UA="Mozilla/5.0 (X11; Linux x86_64; rv:24.0) Gecko/20100101 Firefox/24.0"
	HOSTPATH='"$HOSTPATH"'

	fetch_http() {
		# FIXME: All of the QUERYx for HTTP use the -k flag since people could install their own certs.
		# FIXME continued: If there was some policy that people cannot be expected to install new certs, they can be removed.
		# First, try a standard HEAD request.  Malformed URL or failed DNS resolve immediately halt.
		QUERY1=$(curl -sIkLA "$UA" -m 15 -o /dev/null -w %{http_code} -- "$1")
		ERRCODE=$?
		[[ "$QUERY1" == "200" ]] && return 0
		[[ "$ERRCODE" -eq 3 ]] && echo "http: Malformed URL $@." >&2 && return 1
		[[ "$ERRCODE" -eq 6 ]] && echo "http: DNS lookup failed for $@." >&2 && return 1

		# Second chance, for those that block HEAD.  Use GET, but with a partial request for the first byte only.
		# 206 is expected, but some that follow spec badly still give 200 OK.
		QUERY2=$(curl -skLA "$UA" -m 15 -o /dev/null --header "Range: bytes=0-1" -w %{http_code} -- "$1")
		{ [[ "$QUERY2" == "206" ]] || [[ "$QUERY2" == "200" ]]; } && return 0

		# Last chance!  Make curl use GET, but internally think it asked for HEAD.  Stops it fetching actual content.
		QUERY3=$(curl -sIkLA "$UA" -X GET -m 15 -o /dev/null -w %{http_code} -- "$1")
		{ [[ "$QUERY3" == "206" ]] || [[ "$QUERY3" == "200" ]]; } && return 0

		# We tried our very best.
		[[ "$QUERY3" == "000" ]] && echo "http: Connection to $@ timed out." >&2 && return 1
		echo "http: HTTP $QUERY3 returned for $@." >&2 && return 1
	}

	fetch_ftp() {
		QUERY1=$(curl -sLIm 15 -o /dev/null -w %{http_code} -- "$1")
		ERRCODE=$?
		[[ "$QUERY1" == 350 ]] && return 0
		[[ "$ERRCODE" -eq 3 ]] && echo "ftp: Malformed URL $@." >&2 && return 1
		[[ "$ERRCODE" -eq 6 ]] && echo "ftp: DNS lookup failed for $@." >&2 && return 1
		[[ "$QUERY1" == "000" ]] && echo "ftp: Connection to $@ timed out." >&2 && return 1
		echo "ftp: FTP $QUERY1 returned for $@." >&2 && return 1
	}

	fetch_git() {
		case "$2" in
			"tag")
				./3.2-expect "$1" "$HOSTPATH/3.1-gitwrap" "refs/tags/$3" &>/dev/null && return 0
				;;
			"branch")
				./3.2-expect "$1" "$HOSTPATH/3.1-gitwrap" "refs/heads/$3" &>/dev/null && return 0
				;;
			"commit"|"")
				# FIXME: You cannot query remote for a given SHA... but who would make up a whole giant hash?
				./3.2-expect "$1" "$HOSTPATH/3.1-gitwrap" &>/dev/null && return 0
				;;
			*)
				false
				;;
		esac

		RETURNVAL=$?
		case "$RETURNVAL" in
			"1")
				echo "git: Unrecognised selector fragment in $@." >&2
				;;
			"2")
				echo "git: Remote repository no longer contains the requested fragment for $@." >&2
				;;
			"99")
				echo "git: Connection forcibly timed out to $@." >&2
				;;
			"128")
				echo "git: Could not connect to $@." >&2
				;;
			*)
				echo "git: Unexpected error ($RETURNVAL) requesting $@." >&2
				;;
		esac
		return 1
	}

	fetch_svn() {
		case "$2" in
			"revision")
				RETURNVAL=$(svn info -r "$3" -- "$1" 2>&1)
				[[ $? == 0 ]] && return 0
				RETURNVAL=$(echo "$RETURNVAL" | grep -o "E[0-9]*" | tail -1)
				;;
			"")
				RETURNVAL=$(svn info -- "$1" 2>&1)
				[[ $? == 0 ]] && return 0
				RETURNVAL=$(echo "$RETURNVAL" | grep -o "E[0-9]*" | tail -1)
				;;
			*)
				false
				;;
		esac

		case "$RETURNVAL" in
			"1")
				echo "svn: Unrecognised selector fragment in $@." >&2
				;;
			"E000110")
				echo "svn: No repository found at $@." >&2
				;;
			"E160006")
				echo "svn: No such revision found for $@." >&2
				;;
			"E200009")
	 			echo "svn: Remote repository no longer contains the requested fragment for $@." >&2
	 			;;
	 		*)
	 			echo "svn: Unexpected error ($RETURNVAL) requesting $@." >&2
	 			;;
	 	esac
		return 1
	}

	fetch_bzr() {
		bzr revno -- "$1" &>/dev/null && return 0
		RETURNVAL=$?
		case "$RETURNVAL" in
			"3")
 				echo "bzr: No repository found at $@." >&2
 				;;
	 		*)
	 			echo "bzr: Unexpected error ($RETURNVAL) requesting $@." >&2
	 			;;
	 	esac
		return 1
	}

	fetch_hg() {
		case "$2" in
			"branch"|"revision"|"tag")
				RETURNVAL=$(hg id -r "$3" -- "$1" 2>&1)
				[[ $? == 0 ]] && return 0
				RETURNVAL=$(echo "$RETURNVAL" | grep "^abort: ")
				;;
			"")
				RETURNVAL=$(hg id -r tip -- "$1" 2>&1)
				[[ $? == 0 ]] && return 0
				RETURNVAL=$(echo "$RETURNVAL" | grep "^abort: ")
				;;
			*)
				RETURNVAL="Unrecognised selector fragment."
				;;
		esac
		echo "hg: Failed fetching $@: $RETURNVAL" >&2
		return 1
	}

	fetch_rsync() {
		rsync --list-only -- "$1" &>/dev/null && return 0
		RETURNVAL=$?
		case "$RETURNVAL" in
			"5")
				echo "rsync: No files found at $@." >&2
				;;
			"10")
				echo "rsync: Could not connect to the server at $@." >&2
				;;
	 		*)
	 			echo "rsync: Unexpected error ($RETURNVAL) requesting $@." >&2
	 			;;
	 	esac
		return 1
	}

	URLS=( {} )
	for URL in "${URLS[@]}"
	do
		URLMINUSHINT="${URL#*+}"
		PROTOCOL="${URL%%://*}"
		HINT="${PROTOCOL%%+*}"
		VCSSELECTOR=${URL##*#}
		VCSSELECTORNAME=${VCSSELECTOR%%=*}
		VCSSELECTORVAL=${VCSSELECTOR#*=}
		[[ "$URL" == "$VCSSELECTOR" ]] && unset VCSSELECTORNAME && unset VCSSELECTORVAL
		
		if [[ "$URL" != "" ]]; then
			case "$PROTOCOL" in
			 	"http"|"https")
			 		fetch_http "$URL" && echo "$URL"
			 		;;
			 	"ftp")
			 		fetch_ftp "$URL" &&	echo "$URL"
			 		;;
			 	"git")
			 		fetch_git "${URL%%#*}" "$VCSSELECTORNAME" "$VCSSELECTORVAL" && echo "$URL"
			 		;;
			 	"svn")
					fetch_svn "${URL%%#*}" "$VCSSELECTORNAME" "$VCSSELECTORVAL" && echo "$URL"
					;;
			 	"bzr")
					fetch_bzr "${URL%%#*}" && echo "$URL"
			 		;;
			 	"hg")
			 		fetch_hg "${URL%%#*}" "$VCSSELECTORNAME" "$VCSSELECTORVAL" && echo "$URL"
			 		;;
			 	"rsync")
					fetch_rsync "$URL" && echo "$URL"
			 		;;
			 	"scp")
			 		# TODO
			 		;;
			 	*)
			 		case "$HINT" in
			 			"git")
			 				fetch_git "${URLMINUSHINT%%#*}" "$VCSSELECTORNAME" "$VCSSELECTORVAL" && echo "$URL"
			 				;;
			 			"svn")
			 				fetch_svn "${URLMINUSHINT%%#*}" "$VCSSELECTORNAME" "$VCSSELECTORVAL" && echo "$URL"
			 				;;
			 			"bzr")
			 				fetch_bzr "${URLMINUSHINT%%#*}" && echo "$URL"
			 				;;
			 			"hg")
			 				fetch_hg "${URLMINUSHINT%%#*}" "$VCSSELECTORNAME" "$VCSSELECTORVAL" && echo "$URL"
			 				;;
			 			*)
			 				echo "???: Unrecognised protocol, checking failed for $URL." >&2
			 				;;
			 		esac
			 		;;
			esac
		fi
	done
	' :::: ./res/urllist >res/goodurls 2>res/faillog
}

genreport() {
	cat <<REPORTHEADER
Each package was sourced in a container with only base and base-devel, with a read-only working directory and no network connection.  This is intentional, since the act of sourcing should not be writing files, downloading files, or using anything that cannot be checked against the dependency array by makepkg first.
This may mean that some instances of a message such as 'wrote to stdout' or 'wrote to stderr' are not where the PKGBUILD actively uses a msg-like function, but where it attempts to download or write a file to disk.

REPORTHEADER

	echo "==========================================================[Extraction]"
	if [[ "$VERBOSITY" -ge 5 ]]; then
		cat res/extractbugs
	elif [[ "$VERBOSITY" -ge 3 ]]; then
		grep "^E: \|^W: " "./res/extractbugs" | sed 's/:$//'
	else
		grep "^E: " "./res/extractbugs" | sed 's/:$//'
	fi

	if [[ "$VERBOSITY" -ge 3 ]]; then
		echo
		echo "========================================[Extracted folder permissions]"
		if [[ "$VERBOSITY" -ge 5 ]]; then
			cat res/permissionbugs
		else
			sed 's|.*/||' "./res/permissionbugs"
		fi
	fi

	echo
	echo "=====================================[PKGBUILDs unable to be analysed]"
	pushd ./res/temporary >/dev/null
	if [[ "$VERBOSITY" -ge 3 ]]; then
		for j in $(
			for i in *
			do
				[[ -e "$i" ]] || continue
				echo "${i%-*}"
			done | uniq)
		do
			echo "$j:"
			for k in "$j-"*
			do
				[[ -e "$k" ]] || continue
				[[ -s "$k" ]] && tail -v "$k"
			done
			echo
		done
	else
		for i in *
		do
			[[ -e "$i" ]] || continue
			echo "${i%-*}"
		done | uniq 
	fi
	popd >/dev/null

	echo
	echo "=================================================[Main package faults]"
	pushd ./res/sourced/ >/dev/null
	##################################
	# TODOS
	##################################
	#
	# .asc and .sig files without SKIP hash.
	# local files with hashes that don't match.
	# Scope to make dependency checking stronger (dependencies of other dependencies)
	#Â Check non-depends to ensure no duplication of depends.
	# Executables in AUR source archives (?)
	# Lack of sources, suggesting code in src.
	# Packages with ONLY ARM architectures.
	# Allow checking of splitpkgs (pkgname can be an array)
	# Check all arrays aren't duplicating any data.
	#
	# For bad packages, three extra messages:
	# - This package is an orphan
	# - This package is over a year old
	# - This package has <=5 // >=100 votes
	#
	##################################
	expac -Sg '%n' base-devel | SHELL=/usr/bin/bash parallel -j8 'pactree -sl {}' | awk '{print $1;}' | awk 'BEGIN{RS=ORS="\n"}!a[$0]++' | SHELL=/usr/bin/bash parallel -j8 'expac -S1 "%n=%v  %P" {} | sed "s/  /\n/g" | grep -v "\.so=\|\.so$\|^$"' | awk 'BEGIN{RS=ORS="\n"}!a[$0]++' > ../tmp_basedevel
	expac -S "%n=%v  %P" | sed 's/  /\n/g' > ../tmp_allpkgnames
	# Regular expressions below with a character count have to be written {number\} otherwise parallel understands it as the {n} option.  \{\} is interpreted as \{} instead.
	find . -type f | sort | SHELL=/usr/bin/bash parallel -k -N 50 -j8 '
		inarray() { local insensitive=$1 n=$2 h; shift 2; $insensitive && shopt -s nocasematch; for h; do [[ $n = "$h" ]] || continue; $insensitive && shopt -u nocasematch; return 0; done; shopt -u nocasematch; return 1; }
		insuffixarray() { local insensitive=$1 n=$2 h; shift 2; $insensitive && shopt -s nocasematch; for h; do [[ $n = *"$h" ]] || continue; $insensitive && shopt -u nocasematch; return 0; done; shopt -u nocasematch; return 1; }
		
		dep_wellformatted() { $1 && [[ "$2" =~ ^[0-9a-zA-Z@._+][0-9a-zA-Z@._+-]*((\>|\<|\<=|\>=|=)?[0-9a-zA-Z.]+(-[0-9]+)?)?$ ]] && return 0; ! $1 && [[ "$2" =~ ^[0-9a-zA-Z@._+][0-9a-zA-Z@._+-]*$ ]] && return 0; local TYPE=$($1 && echo "dependency" || echo "unversioned package reference"); echo "[*] Bad $TYPE.  ($2)" && return 1; }
		dep_canbesatisfied() { local OK=false REQDVERSION="${1##*[=><]}"; if [[ "$REQDVERSION" != "$1" ]]; then local PACKAGENAME="${1%%[=><]*}"; grep -ql "^$PACKAGENAME$" ../splitpkgslist && break; local ALLPKGS=$(grep -h "^$PACKAGENAME=" ../tmp_allpkgnames ../pkgslist); while read line; do local VERCMP=$(vercmp "$REQDVERSION" "${line##*=}"); { { [[ "$VERCMP" == 1 ]] && [[ "$1" == *"<"* ]]; } || { [[ "$VERCMP" == 0 ]] && [[ "$1" == *"="* ]]; } || { [[ "$VERCMP" == -1 ]] && [[ "$1" == *">"* ]]; }; } && OK=true && break; done <<< "$ALLPKGS"; $OK || echo "[*] Could not find any package that provided $1."; else grep -ql "^$1$\|^$1=" ../tmp_allpkgnames ../pkgslist ../splitpkgslist || echo "[*] Could not find any package that provided $1."; fi; }
		dep_notinbasedevel() { local PACKAGENAME="${1%%[=><]*}" REQDVERSION="${1##*[=><]}"; [[ "$REQDVERSION" == "$1" ]] && grep -ql "^$PACKAGENAME$\|^$PACKAGENAME=" ../tmp_basedevel && { ! [[ "$ROVERBOSITY" -gt 2 ]] || echo "[*] Base-devel already contains $1."; } && return; [[ "$REQDVERSION" != "$1" ]] && local VERCMP; grep "^$PACKAGENAME=" ../tmp_basedevel | sed "s/*=//" | while read line; do VERCMP=$(vercmp "$REQDVERSION" "${line##*=}"); { { [[ "$VERCMP" == 1 ]] && [[ "$1" == *"<"* ]]; } || { [[ "$VERCMP" == 0 ]] && [[ "$1" == *"="* ]]; } || { [[ "$VERCMP" == -1 ]] && [[ "$1" == *">"* ]]; }; } && { ! [[ "$ROVERBOSITY" -gt 2 ]] || echo "[*] Packages from base-devel already satisfy $1."; } && break; done; }
		dep_nottoolong() { local DESC="${1#*:}"; [[ "$DESC" != "$1" ]] && [[ "${#DESC}" -gt 150 ]] && echo "[*] Optional dependency description excessively long:" && echo "$1"; }

		validate_vcs_suffix() { local SOURCEENTRY PREFIX=false FRAGMENT=true RETURNMSG="" VCSTYPE="${1##*-}"; inarray false "$VCSTYPE" "${!ROVCSTYPES[@]}" || return; inarray false "${ROVCSTYPES[$VCSTYPE]}" "${makedepends[@]}" || RETURNMSG="$RETURNMSG  Failed to declare makedepend on ${ROVCSTYPES[$VCSTYPE]}."; for SOURCEENTRY in "${source[@]}"; do { [[ "$SOURCEENTRY" == "$VCSTYPE://"* ]] || [[ "$SOURCEENTRY" == "$VCSTYPE+"* ]]; } && PREFIX=true && { [[ "${SOURCEENTRY##*#}" == "$SOURCEENTRY" ]] || [[ "${SOURCEENTRY##*#}" != "revision="* ]]; } && FRAGMENT=false; ! $FRAGMENT && $PREFIX && break; done; ! $PREFIX && RETURNMSG="$RETURNMSG  No VCS source array entry found."; $PREFIX && $FRAGMENT && RETURNMSG="$RETURNMSG  Only VCS sources found specified a revision rather than tracking the repository."; [[ "$RETURNMSG" != "" ]] && echo "[*] Bad VCS package:$RETURNMSG"; }
		validate_pkgname() { [[ "$ROVERBOSITY" -ge 4 ]] && [[ "$PKGBUILDIDENTIFIER" != "$ROEXTRACTEDDIRNAME" ]] && echo "[*] Unzipped directory name and package name do not match.  ($ROEXTRACTEDDIRNAME =/= $PKGBUILDIDENTIFIER)"; local NAME && for NAME in "${pkgname[@]}" "${pkgbase[@]}"; do [[ "$NAME" =~ ^[0-9a-zA-Z@._+][0-9a-zA-Z@._+-]*$ ]] || echo "[*] Package name contains characters outside the permitted range.  ($NAME)"; validate_vcs_suffix "$NAME"; done; }
		validate_pkgver() { [[ "$pkgrel" =~ [^A-Za-z0-9._] ]] && echo "[*] Disallowed pkgver format.  ($pkgver)"; }
		validate_pkgrel() { [[ "$ROVERBOSITY" -ge 3 ]] && [[ "$pkgrel" =~ [^0-9] ]] && echo "[*] Non-integer or negative pkgrel.  ($pkgrel)"; }
		validate_pkgdesc() { [[ "$ROVERBOSITY" -ge 3 ]] && grep -qwf <(echo "$PKGBUILDIDENTIFIER") <(echo "$pkgdesc") && echo "[*] Found package name inside pkgdesc. ($PKGBUILDIDENTIFIER)"; { { [[ "$ROVERBOSITY" == 3 ]] && [[ ${#pkgdesc} -gt 150 ]]; } || { [[ "$ROVERBOSITY" == 4 ]] && [[ ${#pkgdesc} -gt 100 ]]; } || { [[ "$ROVERBOSITY" -ge 5 ]] && [[ ${#pkgdesc} -gt 70 ]]; } } && echo "[*] Pkgdesc is excessively long. (${#pkgdesc} chars)"; }
		validate_url() { grep -qxFf <(echo "$url" | sed "\|://|!d;s|/$||") "../urllist" && echo "[*] Could not connect to address in url field.  ($url)"; }
		validate_arch() { [[ "$ROVERBOSITY" -ge 2 ]] && local ARCHITECTURENAME && for ARCHITECTURENAME in "${arch[@]}"; do inarray false "$ARCHITECTURENAME" "${ROVALIDARCHES[@]}" || echo "[*] Architecture not recognised.  ($ARCHITECTURENAME)"; done; }
		validate_license() { [[ "$ROVERBOSITY" -ge 4 ]] && local LICENSENAME && for LICENSENAME in "${license[@]}"; do [[ "$LICENSENAME" == "custom" ]] || { [[ "$LICENSENAME" == "custom:"?* ]] && { ! inarray true "${LICENSENAME#custom:}" "${ROVALIDILICENSES[@]}" && ! inarray false "${LICENSENAME#custom:}" "${ROVALIDLICENSES[@]}"; }; } || inarray true "$LICENSENAME" "${ROVALIDILICENSES[@]}" || inarray false "$LICENSENAME" "${ROVALIDLICENSES[@]}" || echo "[*] Bad license name.  ($LICENSENAME)"; done; }
		validate_pkgdir() { [[ "$pkgdir" != "" ]] && echo "[*] Sets pkgdir.  (To $pkgdir)"; }
		validate_srcdir() { [[ "$srcdir" != "" ]] && echo "[*] Sets srcdir.  (To $srcdir)"; }
		validate_startdir() { [[ "$startdir" != "" ]] && echo "[*] Sets startdir.  (To $startdir)"; }
		validate_epoch() { [[ "$ROVERBOSITY" -ge 3 ]] && [[ "$epoch" =~ [^0-9] ]] && echo "[*] Non-integer or negative epoch.  ($epoch)"; }
		validate_pkgbase() { return; } # Handled by pkgname where needed.
		validate_groups() { [[ "$ROVERBOSITY" -ge 5 ]] && [[ $(IFS=""; echo "${groups}[@]") != "" ]] && echo "[*] AUR packages gain no benefit from having a defined group."; }
		validate_install() { [[ $install != "" ]] && [ ! -f "../../prep/ext/$ROEXTRACTEDDIRNAME/$install" ] && echo "[*] Install file not found in archive.  ($install)"; }
		validate_changelog() { [[ "$changelog" != "" ]] && [ ! -f "../../prep/ext/$ROEXTRACTEDDIRNAME/$changelog" ] && "[*] Changelog file not found in archive.  ($changelog)"; }
		
		validate_depends() { local DEPENDENCYLINE && for DEPENDENCYLINE in "${depends[@]}"; do dep_wellformatted true "$DEPENDENCYLINE" && dep_canbesatisfied "$DEPENDENCYLINE"; done; }
		validate_makedepends() { local DEPENDENCYLINE && for DEPENDENCYLINE in "${makedepends[@]}"; do dep_wellformatted true "$DEPENDENCYLINE" && dep_notinbasedevel "$DEPENDENCYLINE" && dep_canbesatisfied "$DEPENDENCYLINE"; done; }
		validate_checkdepends() { [[ "${#checkdepends[@]}" != 0 ]] && ! declare -p pkgbuildfunction_package >/dev/null 2>&1 && echo "[*] Contains checkdepends but no check function." && return; local DEPENDENCYLINE && for DEPENDENCYLINE in "${checkdepends[@]}"; do dep_wellformatted true "$DEPENDENCYLINE" && dep_notinbasedevel "$DEPENDENCYLINE" && dep_canbesatisfied "$DEPENDENCYLINE"; done; }
		validate_optdepends() { local DEPENDENCYLINE && for DEPENDENCYLINE in "${optdepends[@]}"; do dep_wellformatted false "${DEPENDENCYLINE%%:*}" && dep_notinbasedevel "${DEPENDENCYLINE%%:*}" && dep_canbesatisfied "${DEPENDENCYLINE%%:*}" && [[ "$ROVERBOSITY" -ge 5 ]] && dep_nottoolong "$DEPENDENCYLINE"; done; }
		validate_conflicts() { local DEPENDENCYLINE && for DEPENDENCYLINE in "${conflicts[@]}"; do dep_wellformatted false "$DEPENDENCYLINE" && dep_canbesatisfied "$DEPENDENCYLINE"; done; }
		validate_replaces() { local DEPENDENCYLINE && for DEPENDENCYLINE in "${replaces[@]}"; do dep_wellformatted false "$DEPENDENCYLINE"; done; }
		validate_provides() { local PROVIDEDPACKAGE && for PROVIDEDPACKAGE in "${provides[@]}"; do [[ "$PROVIDEDPACKAGE" =~ ^[0-9a-zA-Z@._+-]+(=[0-9a-zA-Z._]+)?$ ]] || { echo "[*] Invalid provides declaration ($PROVIDEDPACKAGE)" && continue; }; [[ "$ROVERBOSITY" -ge 3 ]] && [[ "${PROVIDEDPACKAGE%%=*}" == "$PKGBUILDIDENTIFIER" ]] && echo "[*] Package provides itself."; done; }
		
		validate_backup() { [[ "$ROVERBOSITY" -ge 3 ]] && { local BACKUPFILE ABSOLUTE=false && for BACKUPFILE in "${backup[@]}"; do [[ "$BACKUPFILE" == "/"* ]] && ABSOLUTE=true; [[ "$ROVERBOSITY" -ge 5 ]] && [[ "${BACKUPFILE#/}" != "etc/"* ]] && [[ ! "${BACKUPFILE##*/}" =~ (cfg|conf) ]] && echo "[*] Potentially unneeded backup of $BACKUPFILE"; done; $ABSOLUTE && echo "[*] Absolute filepaths found in backup array."; }; }
		validate_options() { [[ "$ROVERBOSITY" -ge 3 ]] && local OPTIONNAME && for OPTIONNAME in "${options[@]}"; do { [[ $OPTIONNAME == "" ]] || inarray false "${OPTIONNAME#!}" "${ROVALIDOPTIONS[@]}"; } || echo "[*] Unknown option.  ($OPTIONNAME)"; done; }
		validate_source() { local SOURCEPATH URLLIST=() LOCALLIST=() COMPARETO && for SOURCEPATH in "${source[@]}"; do [[ $(expr index "$SOURCEPATH" "://") != 0 ]] && URLLIST+=("$SOURCEPATH") && continue; [[ ! -f "../../prep/ext/$ROEXTRACTEDDIRNAME/$SOURCEPATH" ]] && echo "[*] Source entry $SOURCEPATH not found in the archive."; done; COMPARETO=$(IFS=$'"'\n'"'; grep -Fxf <(echo "${URLLIST[*]}" | sed "s|::|\n|;s|^.*\n||;s|/$||") "../urllist"); [[ "$COMPARETO" != "" ]] && echo "[*] Could not connect to the following sources:" && echo "$COMPARETO"; }
		validate_noextract() { [[ "$ROVERBOSITY" -ge 3 ]] && local NOEXTRACTFILE SOURCEFILE FOUND && for NOEXTRACTFILE in "${noextract[@]}"; do FOUND=false; for SOURCEFILE in "${source[@]}"; do SOURCEFILE="${SOURCEFILE%%::*}"; SOURCEFILE="${SOURCEFILE##*/}"; [[ "$SOURCEFILE" == "$NOEXTRACTFILE" ]] && FOUND=true && break; done; $FOUND || echo "[*] Told not to extract a file, $NOEXTRACTFILE, that was not found in the source array."; done; }
		validate_md5sums() { [[ "${#md5sums[@]}" != 0 ]] && NUMSUMTYPES=$((NUMSUMTYPES + 1)) && local MD5SUM && for MD5SUM in "${md5sums[@]}"; do { [[ "$MD5SUM" == "SKIP" ]] || [[ "$MD5SUM" =~ ^[0-9a-f]{32\}$ ]]; } && NUMSUMS=$((NUMSUMS + 1)) || echo "[*] Malformed md5sum.  ($MD5SUM)"; done; }
		validate_sha1sums() { [[ "${#sha1sums[@]}" != 0 ]] && NUMSUMTYPES=$((NUMSUMTYPES + 1)) && local SHA1SUM && for SHA1SUM in "${sha1sums[@]}"; do { [[ "$SHA1SUM" == "SKIP" ]] || [[ "$SHA1SUM" =~ ^[0-9a-f]{40\}$ ]]; } && NUMSUMS=$((NUMSUMS + 1)) || echo "[*] Malformed sha1sum.  ($SHA1SUM)"; done; }
		validate_sha256sums() { [[ "${#sha256sums[@]}" != 0 ]] && NUMSUMTYPES=$((NUMSUMTYPES + 1)) && local SHA256SUM && for SHA256SUM in "${sha256sums[@]}"; do { [[ "$SHA256SUM" == "SKIP" ]] || [[ "$SHA256SUM" =~ ^[0-9a-f]{64\}$ ]]; } && NUMSUMS=$((NUMSUMS + 1)) || echo "[*] Malformed sha256sum.  ($SHA256SUM)"; done; }
		validate_sha384sums() { [[ "${#sha384sums[@]}" != 0 ]] && NUMSUMTYPES=$((NUMSUMTYPES + 1)) && local SHA384SUM && for SHA384SUM in "${sha384sums[@]}"; do { [[ "$SHA384SUM" == "SKIP" ]] || [[ "$SHA384SUM" =~ ^[0-9a-f]{96\}$ ]]; } && NUMSUMS=$((NUMSUMS + 1)) || echo "[*] Malformed sha384sum.  ($SHA384SUM)"; done; }
		validate_sha512sums() { [[ "${#sha512sums[@]}" != 0 ]] && NUMSUMTYPES=$((NUMSUMTYPES + 1)) && local SHA512SUM && for SHA512SUM in "${sha512sums[@]}"; do { [[ "$SHA512SUM" == "SKIP" ]] || [[ "$SHA512SUM" =~ ^[0-9a-f]{128\}$ ]]; } && NUMSUMS=$((NUMSUMS + 1)) || echo "[*] Malformed sha512sum.  ($SHA512SUM)"; done; }
		
		validate_STDOUT() {  [[ "$ROVERBOSITY" -ge 2 ]] && echo "[*] Wrote to stdout during sourcing:"; echo "$STDOUT"; }
		validate_STDERR() { echo "[*] Wrote to stderr during sourcing:"; echo "$STDERR"; }
		validate_PKGEXT() { insuffixarray false "$PKGEXT" "${ROVALIDPKGEXTS[@]}" || echo "[*] Unknown forced PKGEXT value.  ($PKGEXT)"; }
		validate_CARCH() { [[ "$ROVERBOSITY" -ge 3 ]] && echo "[*] Changes CARCH.  ($CARCH)"; }
		validate_CFLAGS() { [[ "$ROVERBOSITY" -ge 3 ]] && echo "[*] Modifies user-set cflags.  ($CFLAGS)"; }
		validate_CHOST() { [[ "$ROVERBOSITY" -ge 3 ]] && echo "[*] Changes CHOST.  ($CHOST)"; }
		validate_CPPFLAGS() { [[ "$ROVERBOSITY" -ge 3 ]] && echo "[*] Modifies user-set cppflags.  ($CPPFLAGS)"; }
		validate_CXXFLAGS() { [[ "$ROVERBOSITY" -ge 3 ]] && echo "[*] Modifies user-set cxxflags.  ($CXXFLAGS)"; }
		validate_DEBUG_CFLAGS() { [[ "$ROVERBOSITY" -ge 3 ]] && echo "[*] Modifies user-set debug cflags.  ($DEBUG_CFLAGS)"; }
		validate_DEBUG_CXXFLAGS() { [[ "$ROVERBOSITY" -ge 3 ]] && echo "[*] Modifies user-set debug cxxflags.  ($DEBUG_CXXFLAGS)"; }
		validate_LDFLAGS() { [[ "$ROVERBOSITY" -ge 3 ]] && echo "[*] Modifies user-set ldflags.  ($LDFLAGS)"; }
		validate_MAKEFLAGS() { [[ "$ROVERBOSITY" -ge 3 ]] && echo "[*] Modifies user-set makeflags.  ($MAKEFLAGS)"; }
		validate_MAKEOPTS() { [[ "$ROVERBOSITY" -ge 3 ]] && echo "[*] Modifies user-set makeopts.  ($MAKEOPTS)"; }
		validate_DLAGENTS() { local DLAGENT && for DLAGENT in "${DLAGENTS[@]}"; do DLAGENT="${DLAGENT%%::*}"; inarray false "$DLAGENT" "${RODEFAULTDLAGENTS[@]}" && echo "[*] Redefines default DLAGENT for $DLAGENT." || { [[ "$ROVERBOSITY" -ge 5 ]] && echo "[*] Defines DLAGENT for $DLAGENT"; }; done; }
		

		validate_archivefiles() { return; }
		validate_disgustingstrings() { local FUNCTIONNAME && for FUNCTIONNAME in "${PKGBUILDFUNCTIONS[@]}"; do echo "${!FUNCTIONNAME}" | grep -wq "sudo" && echo "[*] Found using sudo within ${FUNCTIONNAME#pkgbuildfunction_}()."; echo "${!FUNCTIONNAME}" | tr "\n" " "  | grep -Eq "\|\|[[:space:]]*return" && echo "[*] Found using || return within ${FUNCTIONNAME#pkgbuildfunction_}()."; echo "${!FUNCTIONNAME}" | tr "\n" " "  | grep -Eq "[[:space:]](CARCH|CFLAGS|CHOST|CPPFLAGS|CXXFLAGS|DEBUG_CFLAGS|DEBUG_CXXFLAGS|LDFLAGS|MAKEFLAGS|MAKEOPTS)+?=" && echo "[*] Found changing MAKEOPTS within ${FUNCTIONNAME#pkgbuildfunction_}()."; done; }
		validate_package_function() { declare -p pkgbuildfunction_package >/dev/null 2>&1 || echo "[*] PKGBUILD has no package() function."; }

		INPUT=( {} )
		for PACKAGE in "${INPUT[@]}"
		do
			EXTRACTEDDIRNAME="${PACKAGE##*/}"
			APPLICABLEARCHES="${EXTRACTEDDIRNAME##*-}"
			EXTRACTEDDIRNAME="${EXTRACTEDDIRNAME%-*}"
			RESULT=$(
				readonly ROVALIDARCHES=(any x86_64 i686 arm armv6h armv7h) # Order these with most popular first, since inarray ends early in such cases.
				readonly ROVALIDOPTIONS=(strip docs libtool staticlibs emptydirs zipman purge upx debug ccache distcc buildflags makeflags)
				readonly ROVALIDILICENSES=(AGPL AGPL3 Artistic2.0 CCPL CDDL CPL EPL FDL FDL1.2 FDL1.3 GPL GPL2 GPL3 LGPL LGPL2.1 LGPL3 LPPL MPL PerlArtistic PHP PSF RUBY W3C ZPL zsync BSD MIT Python zlib/libpng)
				readonly ROVALIDLICENSES=(Apache APACHE)
				readonly ROVALIDPKGEXTS=(tar.gz tar.bz2 tar.xz tar.lrz tar.lzo tar.Z tar)
				readonly RODEFAULTDLAGENTS=(http https ftp rsync scp)
				declare -Ar ROVCSTYPES=([svn]=subversion [bzr]=bzr [git]=git [hg]=mercurial)
				# End of array markers below for iteration assistance.
				ROALLPKGFIELDS=(pkgname) # Special case.  Required string-or-array.
				ROALLPKGFIELDS+=(pkgdesc pkgrel pkgver url -) # REQUIRED STRINGS
				ROALLPKGFIELDS+=(arch license --) # REQUIRED ARRAYS
				ROALLPKGFIELDS+=(changelog epoch install pkgbase pkgdir srcdir startdir PKGEXT MAKEFLAGS MAKEOPTS DEBUG_CFLAGS DEBUG_CXXFLAGS CARCH LDFLAGS CFLAGS CPPFLAGS CXXFLAGS CHOST STDOUT STDERR ---) # OTHER STRINGS
				ROALLPKGFIELDS+=(backup checkdepends conflicts depends groups makedepends md5sums noextract optdepends options provides replaces sha1sums sha256sums sha384sums sha512sums source DLAGENTS) # OTHER ARRAYS
				readonly ROALLPKGFIELDS

				readonly ROEXTRACTEDDIRNAME="$EXTRACTEDDIRNAME"
				readonly ROVERBOSITY="'"$VERBOSITY"'"

				source "$PACKAGE" 2>/dev/null
				grep -ql $'"'\r'"' <(declare -p) && echo "Aborting: Found line feeds.  Remember, CRLF PKGBUILDs cannot be sourced by makepkg." && exit
				
				if [[ "$ROVERBOSITY" -ge 3 ]]; then
					PKGBUILDFUNCTIONS=()
					ALLSETVARS=($(sed "/^_/d;s/=.*//" "$PACKAGE"))
					for SETVARIABLE in "${ALLSETVARS[@]}"
					do
						[[ "$SETVARIABLE" =~ ^pkgbuildfunction_ ]] && PKGBUILDFUNCTIONS+=("$SETVARIABLE") && continue
						{ ! [[ "$SETVARIABLE" =~ -+ ]] && inarray false "$SETVARIABLE" "${ROALLPKGFIELDS[@]}"; } || echo "[*] Unknown non-underscored variable set with name $SETVARIABLE."
					done
				fi

				PKGBUILDIDENTIFIER=$({ [[ "${#pkgname[*]}" -gt 1 ]] && [[ "$pkgbase" != "" ]] && echo $pkgbase; } || echo "$pkgname")
				REQUIREDFIELD=true
				ISSTRING=true
				NUMSUMS=0
				NUMSUMTYPES=0
				for PKGBUILDFIELD in "${ROALLPKGFIELDS[@]}"
				do
					$REQUIREDFIELD && [[ "$PKGBUILDFIELD" == "-" ]] && ISSTRING=false && continue
					$REQUIREDFIELD && [[ "$PKGBUILDFIELD" == "--" ]] && REQUIREDFIELD=false && ISSTRING=true && continue
					[[ "$PKGBUILDFIELD" == "---" ]] && ISSTRING=false && continue
					VARIABLETYPE=$(declare -p "$PKGBUILDFIELD" 2>/dev/null | cut -d " " -f 2)
					if [[ "$VARIABLETYPE" != "" ]]; then
						if [[ "$PKGBUILDFIELD" == "pkgname" ]]; then
							# Special case, can be both.
							[[ "${pkgname[*]}" =~ ^[\ ]*$ ]] && echo "[*] Essential field $PKGBUILDFIELD has been left blank."
							validate_pkgname
						elif $ISSTRING && [[ "$VARIABLETYPE" =~ ^[^Aa]+$ ]]; then
							$REQUIREDFIELD && [[ "${!PKGBUILDFIELD}" == "" ]] && echo "[*] Essential field $PKGBUILDFIELD has been left blank."
							validate_$PKGBUILDFIELD
						elif ! $ISSTRING && [[ "$VARIABLETYPE" == *[Aa]* ]]; then
							$REQUIREDFIELD && TMPVAR="$PKGBUILDFIELD""[@]" && [[ "${!TMPVAR}" == "" ]] && echo "[*] Essential field $PKGBUILDFIELD has been left blank."
							validate_$PKGBUILDFIELD
						else
							$ISSTRING && echo "[*] Skipping $PKGBUILDFIELD.  Should be a string but was an array." || echo "[*] Skipping $PKGBUILDFIELD.  Should be an array but was a string."
						fi
					fi
				done

				[[ "$NUMSUMS" != "${#source[@]}" ]] && echo "[*] Number of hashes ($NUMSUMS) does not match number of entries in the source array (${#source[@]})."
				[[ "$NUMSUMTYPES" -gt 1 ]] && echo "[*] More than one type of hash is used to describe the source array ($NUMSUMTYPES)."

				validate_archivefiles
				[[ "$ROVERBOSITY" -ge 2 ]] && validate_package_function
				[[ "$ROVERBOSITY" -ge 2 ]] && validate_disgustingstrings

				exit 0
			)
			[[ $? == 1 ]] && RESULT="Aborting: Could not load data, likely due to use of an associative array."
			
			[[ $RESULT != "" ]] && echo "[o] $EXTRACTEDDIRNAME ($APPLICABLEARCHES)" && echo "$RESULT" && echo
		done
	'
	popd >/dev/null
}

VERBOSITY=0
while getopts "v" OPTION; do
	case "$OPTION" in
		v)
			VERBOSITY=$((VERBOSITY+1))
			;;
	esac	
done
[[ "$VERBOSITY" == "0" ]] && VERBOSITY=1

# prep
# coalesce
# urlcheck
# coalesce
# urlcheck
# coalesce
genreport